//插件用于扩展gradle脚本的能力，在一个项目中使用插件，该项目的构建脚本就可以定义该插件定义好的属性和使用它的tasks
apply plugin: 'com.android.application'//应用此插件，可构建应用程序
//apply plugin: 'com.android.library'//应用此插件，可构建依赖库，两者不能同时应用

android {
    //必须有的两个属性
    compileSdkVersion rootProject.ext.compileSdkVersion     //编译时使用的sdk版本，建议（总是）采用最新版本
    buildToolsVersion rootProject.ext.buildToolsVersion     //构建工具的版本号

    //默认配置,重写AndroidManifest或在其上添加 自定义属性
    defaultConfig {
        applicationId "com.eyesmart.testapplication"    //只会修改当前程序的包名,不影响源码中资源文件对包名的引用
        minSdkVersion 19                                //最小支持的sdk版本（必须>=所有依赖库所支持的最低版本）
        targetSdkVersion 22
        //目标sdk版本（compileSdkVersion采用了23（6.0），但是项目暂时还未对6.0的特性（如运行时权限）做相应的处理，那么可以设置targetSdkVersion的版本低于23。这样，应用仍可以正常运行在6.0的机子上（当然也就不具有运行时权限的特性）。）
        versionCode 1                                   //app版本号
        versionName "1.0"                               //app版本名，无作用
        flavorDimensions "versionCode"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

        ndk {
            moduleName "TestJni"                        //生成的so名字
            abiFilters "armeabi", "armeabi-v7a", "x86"  //输出指定三种abi体系结构下的so库。目前可有可无。
        }
    }

    //产品风味，重写默认配置或在其上添加 自定义属性
    productFlavors {
        flavor {
        }
        myflavors {
            applicationIdSuffix ".myflavors"
            //signingConfig signingConfigs.release
        }
    }

    //签名配置
    signingConfigs {
        staging.initWith(signingConfigs.debug)
        release {
            //storeFile file("release.keystore")                //可以这样，文件路径
            storeFile file(System.properties['keyStore'])       //可以这样
            storePassword System.properties['keyStorePassword']
            keyAlias project.property('testapp.keyAlias')       //也可以这样
            keyPassword testKeyAliasPassword                    //还可以这样
        }
    }

    //编译类型，重写产品风味或在其上添加 自定义属性
    buildTypes {
        debug {
            buildConfigField "String", "API_URL", "\"http://test.example.com/api\""
            //定义全局常量BuildConfig.API_UR
            resValue "string", "APP_NAME", "TestApp_debug"
            //定义资源 R.string.app_name
        }
        myrelease.initWith(buildTypes.debug)                                        //继承debug编译类型
        myrelease {
            applicationIdSuffix ".myrelease"                                        //自定义包名后缀
            versionNameSuffix "_release"                                            //自定义版本名后缀
            //signingConfig signingConfigs.release
            buildConfigField "String", "API_URL", "\"http://example.com/api\""
            resValue "string", "APP_NAME", "TestApp_myrelease"
        }
        release {
            minifyEnabled true      // 是否进行混淆
            zipAlignEnabled true    //Zipalign优化
            shrinkResources true    // 移除无用的resource文件
            //混淆文件  proguard-android.txt为系统默认的混淆文件，位于\sdk\tools\proguard    proguard-rules.pro为项目自定义混淆文件，用于定义第三方依赖包的混淆规则
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            resValue "string", "APP_NAME", "TestApp_myrelease"
        }
    }

    //保持旧的eclipse文件结构
//    sourceSets {
//        main {
//            aidl.srcDirs = ['src']
//            assets.srcDirs = ['assets']
//            java.srcDirs = ['src']
//            jniLibs.srcDirs =
//            resources.srcDirs = ['src']
//            renderscript.srcDirs = ['src']
//            res.srcDirs = ['res']
//            manifest.srcFile 'AndroidManifest.xml'
//
//            jniLibs.srcDir 'libs'                 //jniLibs: so库依赖路径 (armeabi、armebi-v7a)
//                                                  //libs: jar包依赖路径
//        }
//        androidTest.setRoot('tests')
//    }

    //自定义apk的文件名
//    applicationVariants.all { variant ->
//        variant.outputs.each { output ->
//            if (output.outputFile != null &&
//                    output.outputFile.name.endsWith('.apk') &&
//                    variant.buildType.name == 'myrelease') {        //约束条件
//                def apkFile = new File(output.outputFile.getParent(),
//                        "Eyesmart_${variant.flavorName}_${variant.buildType.name}_ver${variant.versionName}.apk");
//                output.outputFile = apkFile;
//            }
//        }
//    }

    //配置变体过滤器，忽略 myflavorsmyrelease 版本
//    variantFilter { variant ->
//        if (variant.buildType.name.equals('myrelease')) {
//            variant.getFlavors().each() { flavor ->
//                if (flavor.name.equals('myflavors')) {
//                    variant.setIgnore(true);
//                }
//            }
//        }
//    }

    // java版本
//    compileOptions {
//        sourceCompatibility JavaVersion.VERSION_1_7
//        targetCompatibility JavaVersion.VERSION_1_7
//    }

    // 移除lint检查的error
//    lintOptions {
//        abortOnError false
//    }
    sourceSets {
        main {
            jni.srcDirs = []                                    //设置禁止gradle生成Android.mk
            jniLibs.srcDirs = ['src/main/jniLibs']              //设置目标的so存放路径
        }
    }
    repositories {
        flatDir {
            dirs 'libs'//作用是添加一个本地仓库,并把libs目录当做仓库地址
        }
    }
    buildToolsVersion '26.0.2'
}

//依赖的库
dependencies {
    //将libs文件夹中所有的jar文件视为依赖库
    implementation 'com.android.support.constraint:constraint-layout:1.0.2'
    compile fileTree(include: ['*.jar'], dir: 'libs')
    compile(name: 'testlibrary-debug', ext: 'aar')
    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
        //根据不同编译类型，依赖不同的库
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    compile 'com.android.support:appcompat-v7:26.1.0'
    compile 'com.android.support:design:26.1.0'
    implementation 'com.android.support:recyclerview-v7:26.1.0'
    implementation 'com.android.support:palette-v7:26.1.0'
    testCompile 'junit:junit:4.12'
    //用于Java编写执行Java测试用例
    compile 'com.dubsmash.volley:library:2.0.1'
    compile 'com.squareup.okhttp3:okhttp:3.8.1'
    compile 'com.squareup.okhttp3:logging-interceptor:3.8.1'
    compile 'com.squareup.retrofit2:retrofit:2.3.0'
    compile 'com.squareup.retrofit2:converter-scalars:2.3.0'
    compile 'com.squareup.retrofit2:converter-gson:2.3.0'
    compile 'io.reactivex.rxjava2:rxjava:2.1.1'
    compile 'io.reactivex.rxjava2:rxandroid:2.0.1'
    compile 'org.greenrobot:eventbus:3.0.0'
    compile 'jp.wasabeef:glide-transformations:1.0.6'
    compile 'com.github.bumptech.glide:glide:4.0.0'
    debugCompile 'com.squareup.leakcanary:leakcanary-android:1.4-beta2'
    releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta2'

    implementation 'com.jakewharton:butterknife:8.6.0'
    annotationProcessor 'com.jakewharton:butterknife-compiler:8.6.0'

    //implementation
    //这个指令的特点就是，对于使用了该命令编译的依赖，对该项目有依赖的项目将无法访问到使用该命令编译的依赖中的任何程序，
    //也就是将该依赖隐藏在内部，而不对外部公开。
    //编译速度会加快，优先使用
    //    下面是2.x版本依赖的说明，括号里对应的是3.0版本的依赖方式。
    //    compile（api，implementation）
    //    这种是我们最常用的方式，使用该方式依赖的库将会参与编译和打包。
    //    provided（compileOnly）
    //    只在编译时有效，不会参与打包，可以在自己的moudle中使用该方式依赖。比如com.android.support，gson这些使用者常用的库，避免冲突。
    //    apk（runtimeOnly）
    //    只在生成apk的时候参与打包，编译时不会参与，很少用。
    //    testCompile（testImplementation）
    //    testCompile 只在单元测试代码的编译以及最终打包测试apk时有效。
    //    debugCompile（debugImplementation）
    //    debugCompile 只在debug模式的编译和最终的debug apk打包时有效。
    //    releaseCompile（releaseImplementation）
    //    releaseCompile 仅仅针对Release模式的编译和最终的Release apk打包。
}
