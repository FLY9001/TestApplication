package com.eyesmart.testapplication.java;

import android.animation.ValueAnimator;
import android.support.v7.app.AlertDialog;
import android.view.animation.AccelerateDecelerateInterpolator;

import com.eyesmart.testapplication.TestApplication;

/**
 * 设计模式六大原则：
 * 1、单一职责   类要职责单一
 * 2、里氏替换   不破坏继承关系；所有引用基类（父类）的地方必须能透明地使用其子类的对象
 * 3、依赖倒置   面向接口编程（或抽象类）；抽象比细节更稳定
 * 4、接口隔离   接口要精简单一；接口中方法尽量少，可使用多个接口
 * 5、迪米特     降低耦合，一个软件实体应当尽可能少地与其他实体发生相互作用
 * 6、开闭       对扩展开发，对修改关闭；
 */

public class TestDesignPattern {
    void test() throws CloneNotSupportedException {

        //创建型
        Singleton.getInstance();                        //单例模式      类仅一个实例
        ProductFactory.createProduct(ProductA.class);   //工厂模式      代理创建实例，工厂类负责创建实例（只关心得到实例，不关心如何实例创建方式和内部实现），简单工厂模式、工厂方法模式、抽象工厂模式
        new TestBuilder().test();                       //Builder模式   链式创建实例（适用于场景多样、参数较复杂时，如dialog）
        new TestClone().clone();                        //原型模式      克隆实例，快速拷贝一个新对象， 实现Cloneable，重写clone()


        //结构型
        new TestProxy().test();                         //代理模式      中间代理结构(护)，增加中间代理类Proxy，控制一个类的功能，接口名不变
        new TestDecorator().test();                     //装饰模式      中间扩展结构(增)，增加装饰者类Decorator，扩展一个类的功能
        new TestFacade().test();                        //外观模式      中间简化结构(减)，增加外观类，简化一个类的对外的接口
        new TestAdapter().test();                       //适配器模式    中间适配结构(配)，增加适配器Adapter，适配转换一个类对外的接口，满足期待
        new TestBridge().test();                        //桥接模式      中间组合结构(合)，将两种不同功能类，灵活组合，大杯小杯、加糖不加糖组合为咖啡

        new TestFlyweight().test();                     //享元模式      缓存结构，增加缓存类，用HashMap缓存对象，减少创建对象的次数，以减少内存占用和提高性能，如Message.obtain()
        new TestComposite().test();                     //组合模式      树形结构，表示对象之间树形结构，如View和ViewGroup的嵌套组合、Employee


        //行为型
        new TestStrateg().test();                       //策略模式      把算法策略包装成类
        new TestCommand().test();                       //命令模式      把命令包装成类，一条命令为一个对象，调用者→命令→接受者
        new TestState().test();                         //状态模式      把状态包装成类，执行行为后改变状态对象参数，从而记录状态改变行为
        new TestMemento().test();                       //备忘录模式    把此时的数据包装成类，作为对象保存恢复

        new TestTemplate().test();                      //模板模式      抽象类定义方法骨架，子类统一实现和扩展
        new TestObserver().test();                      //观察者模式    抽象类中ArrayList存放观察者们Observer，发生变化时通知观察者
        new TestIterator().test();                      //迭代器模式    父类定义Iterator类，包含接口：hasNext, next，帮助遍历一个聚合对象

        new TestMediator().test();                      //中介者模式    通过中介者类，单独处理对象交互通信
        new TestVisitor().test();                       //访问者模式    访问不同的类，用不同的方法
        new TestChain().test();                         //责任链模式    请求交给责任者，但会依次执行
        //解释器模式
    }
}

//**********************************************************************************************************

/**
 * 单例模式
 * 定义、场景：确保某个类只有一个实例，避免产生多个对象消耗过多的资源
 * 
 * 优点：
 * （1）由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁的创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。
 * （2）单例模式可以避免对资源的多重占用，例如一个文件操作，由于只有一个实例存在内存中，避免对同一资源文件的同时操作。
 * （3）单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。
 * 缺点：
 * （1）单例模式一般没有接口，扩展很困难，若要扩展，只能修改代码来实现。
 * （2）单例对象如果持有Context，那么很容易引发内存泄露。此时需要注意传递给单例对象的Context最好是Application Context。
 * 
 * Android源码：
 * Context获取系统级别的服务，如WindowsManagerService、ActivityManagerService等，和LayoutInflater
 */
//饿汉模式（线程安全，无论是否使用都创建，浪费空间）
class Singleton {
    private static Singleton singleton = new Singleton();

    public static Singleton getInstance() {
        return singleton;
    }
    private Singleton() {
    }
}

//懒汉模式（线程不安全，加锁会影响效率）
class Singleton2 {
    private static Singleton2 singleton2;

    public static synchronized Singleton2 getInstance() {
        if (singleton2 == null) {
            singleton2 = new Singleton2();
        }
        return singleton2;
    }
}

//双重校验懒汉模式，双检锁/双重校验锁DCL（线程安全，降低效率影响，推荐）
class Singleton3 {
    private volatile static Singleton3 singleton3;

    public static Singleton3 getInstance() {
        if (singleton3 == null) {
            synchronized (Singleton3.class) {
                if (singleton3 == null) {
                    singleton3 = new Singleton3();
                }
            }
        }
        return singleton3;
    }
}

//枚举来实现单例；解决序列化对单例的破坏（线程安全，最佳）
enum Singleton4 {
    INSTANCE;

    public void whateverMethod() {
    }

}


//**********************************************************************************************************

/**
 * 工厂模式
 * 定义：定义一个创建对象的接口，让子类去决定实现化哪个类
 * 场景：生成复杂对象时，用工厂去创建产品
 * 
 * 优点：
 * 1.封装了创建过程，降低了对象之间的耦合。高层模块只需要知道产品的抽象类，其他的实现都不需要关心。
 * 2.良好的封装性，代码结构清晰。扩展性好。
 * 缺点：
 * 类结构较复杂，在比较简单时，不需要使用工厂模式。
 * 
 * Android源码：
 * 1.Activity的onCreate可看出工厂方法，因为setContentView
 * 2.ArrayList和HashSet
 */
class ProductFactory {
    /**
     * 抽象工厂方法
     * 具体由子类实现
     *
     * @param clz 产品对象类类型
     * @return 具体的产品对象
     */
    public static <T extends Product> T createProduct(Class<T> clz) {
        Product product = null;
        try {
            product = (Product) Class.forName(clz.getName()).newInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return (T) product;
    }

//    public static Shape getShape(String shapeType){
//        if(shapeType == null){
//            return null;
//        }
//        if(shapeType.equalsIgnoreCase("CIRCLE")){
//            return new Circle();
//        } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
//            return new Rectangle();
//        } else if(shapeType.equalsIgnoreCase("SQUARE")){
//            return new Square();
//        }
//        return null;
//    }
}

abstract class Product {
    /**
     * 产品类的抽象方法
     * 由具体的产品类去实现
     */
    public abstract void method();
}

class ProductA extends Product {

    @Override
    public void method() {
        System.out.println("我是产品A");
    }
}

class ProductB extends Product {

    @Override
    public void method() {
        System.out.println("我是产品B");
    }
}

//**********************************************************************************************************

/**
 * 建造者模式
 * 定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
 * 场景：
 * （1）相同的方法，不同的执行顺序，产生不同的事件结果时。
 * （2）多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时。
 * （3）产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个使用建造者模式非常适合。
 * （4）当初始化一个对象特别复杂时，如参数多，且很多参数有默认值。
 * 
 * 优点：
 * （1）良好的封装性，使用建造者模式可以使客户端不必知道产品内部组成细节。
 * （2）建造者独立，容易扩展。
 * 缺点：
 * （1）会产生多余的Builder对象，消耗内存。
 * 
 * Android源码：
 * AlertDialog.Builder
 */
class TestBuilder {
    void test() {
        new AlertDialog.Builder(TestApplication.getContext())
                .setTitle("弹窗")
                .show();
    }
}

//**********************************************************************************************************

/**
 * 原型模式
 * 定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。被复制的实例就是“原型”，这个原型是可定制的。
 * 场景：
 * （1）类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等，通过原型拷贝避免这些消耗。
 * （2）通过new产生的一个对象需要非常繁琐的数据准备或者权限，这时可以使用原型模式。
 * （3）一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。
 * 
 * 优点：
 * （1）原型模式是在内存中二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量对象时，原型模式可能更好的体现其优点。
 * （2）还有一个重要的用途就是保护性拷贝，也就是对某个对象对外可能是只读的，为了防止外部对这个只读对象的修改，通常可以通过返回一个对象拷贝的形式实现只读的限制。
 * 缺点：
 * （1）这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的，在实际开发中应该注意这个潜在问题。优点是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。
 * （2）通过实现Cloneable接口的原型模式在调用clone函数构造实例时并不一定比通过new操作速度快，只有当通过new构造对象较为耗时或者说成本较高时，通过clone方法才能够获得效率上的提升。
 * 
 * Android源码：
 * Intent
 */
class TestClone implements Cloneable{
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

//**********************************************************************************************************

/**
 * 策略模式
 * 定义：策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。
 * 场景：
 * 1.针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。
 * 2.需要安全地封装多种同一类型的操作时。
 * 3.出现同一抽象类有多个子类，而又需要使用if-else或者switch-case来选择具体子类时。
 * 
 * 优点：
 * 1.结构清晰明了、使用简单直观。
 * 2.耦合度相对而言较低，扩展方便。
 * 3.操作封装也更为彻底，数据更为安全。
 * 缺点：
 * 1.随着策略的增加，子类也会变得繁多。
 * 
 * Android源码：
 * 1.时间插值器（TimeInterpolator）
 */
class TestStrateg {
    void test() {
        ValueAnimator animator = ValueAnimator.ofInt(0, 100);
        animator.setInterpolator(new AccelerateDecelerateInterpolator());  //时间插值器，可自定义
        animator.addListener(null);//监听
        animator.start();
    }
}

//**********************************************************************************************************

/**
 * 状态模式
 * 定义：状态模式中的行为是由状态来决定，不同的状态下有不同的行为。当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
 * 场景：
 * 1.一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。
 * 2.代码中包含大量与对象状态有关的条件语句，例如，一个操作中含有大量的多分支语句，且这些分支依赖于该对象的状态。
 * 
 * 优点
 * 将所有与一个特定的状态相关的行为都放入一个状态对象中，它提供了一个更好的方法来组织与特定状态相关的代码，将繁琐的状态判断转换成结构清晰的状态类族，在避免代码膨胀的同时也保证了可扩展性与可维护性。
 * 缺点
 * 状态模式的使用必然会增加系统类和对象的个数。
 * 
 * Android源码：
 * 1.登录系统，根据用户是否登录，判断事件的处理方式。
 * 2.Wi-Fi管理，在不同的状态下，WiFi的扫描请求处理不一。
 */

class TestState {
    void test() {
    }
}

//**********************************************************************************************************

/**
 * 责任链模式
 * 定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。
 * 场景：
 * 1.多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定。
 * 2.在请求处理者不明确的情况下向多个对象中的一个提交请求。
 * 3.需要动态指定一组对象处理请求。
 * 
 * 优点
 * 可以对请求者和处理者的关系解耦，提高代码的灵活性。
 * 缺点
 * 每次都需要对链中请求处理者遍历，如果处理者太多那么遍历必定会影响性能，特别是在一些递归调用者中，要慎用。
 * 
 * Android源码：
 * View事件的分发处理
 */
class TestChain {
    void test() {
        //公司报销费用
    }
}

//**********************************************************************************************************

/**
 * 命令模式
 * 定义：将一个请求封装成一个对象，从而让用户使用不同的请求把客户端参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。
 * 场景：
 * （1）需要抽出待执行的动作，然后以参数的形式提供出来。
 * （2）在不同的时刻指定、排列和执行请求。一个命令对象可以有与初始请求无关的生存期。
 * （3）需要支持操作取消。
 * （4）支持修改日志功能，这样当系统崩溃时，这些修改可以被重做一遍。
 * （5）需要支持事务操作。
 * 
 * 优点
 * 命令模式的封装性很好，更弱的耦合性，更灵活的控制性以及更好的扩展性。
 * 缺点
 * 类的膨胀，大量衍生类的创建。
 * 
 * Android源码：
 * PackageHandler
 */
class TestCommand {
    void test() {
        //把行为命令作为一个对象
    }
}

//**********************************************************************************************************

/**
 * 观察者模式
 * 定义：观察者模式是一种行为类模式，它定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。
 * 实现观察者模式有很多形式，一种是“注册---通知---撤销注册”的形式
 * 场景：
 * （1）关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。
 * （2）事件多级触发场景。
 * （3）跨系统的消息交换场景，如消息队列、事件总线的处理机制。
 * 
 * 优点
 * （1）观察者和被观察者之间是抽象耦合，应对业务变化。
 * （2）增强系统的灵活性和可扩展性。
 * 缺点
 * 在应用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、多个观察者，开发、调试等内容会比较复杂，
 * 而且在Java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。
 * 
 * Android源码：
 * BaseAdapter
 * RxJava
 */
class TestObserver {
    void test() {
        //给被观察者设置多个观察者，逐一通知
    }
}

//**********************************************************************************************************

/**
 * 备忘录模式
 * 定义：在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样，以后就可将该对象恢复到原先保存的状态。
 * 场景：
 * （1）需要保存一个对象在某一个时刻的状态或部分状态。
 * （2）如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，
 * 一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。
 * 
 * 优点
 * （1）给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史状态。
 * （2）实现了信息的封装，使用户不需要关心状态的保存细节。
 * 缺点
 * 消耗资源，如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。
 * 
 * Android源码：
 * onSaveInstanceState和onRestoreInstanceState
 */
class TestMemento {
    void test() {
        //设置一个备忘录类，保存状态
    }
}

//**********************************************************************************************************

/**
 * 迭代器模式
 * 定义：提供一种方法顺序访问一个容器对象中的各个元素，而又不需要暴露该对象的内部表示。
 * 场景：
 * 遍历一个容器对象时。
 * 
 * 优点
 * （1）符合面向对象设计原则中的单一职责原则。
 * （2）支持对容器对象的多种遍历。弱化了容器类与遍历算法之间的关系。
 * 缺点
 * （1）类文件的增加。
 * （2）遍历过程是一个单向且不可逆的遍历。
 * （3）会出现ConcurrentModificationException异常。
 * 
 * Android源码：
 * 数据库Cursor
 */
class TestIterator {
    void test() {
//        while (iterator.hasNext()) {
//            iterator.next();
//        }
    }
}

//**********************************************************************************************************

/**
 * 模板方法模式
 * 定义：定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
 * 场景：
 * （1）多个子类有公有的方法，并且逻辑基本相同。
 * （2）重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能由各个子类实现。
 * （3）重构时，模板方法是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子方法约束其行为。
 * 
 * 优点
 * （1）封装不变部分，扩展可变部分。
 * （2）提取公共部分代码，便于维护。
 * 缺点
 * 需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，
 * 将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。
 * 
 * Android源码：
 * AsyncTask
 * Activity的生命周期
 */
class TestTemplate {
    void test() {
    }
}

//**********************************************************************************************************

/**
 * 访问者模式
 * 定义：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。
 * 场景：
 * （1）对象结构比较稳定，但经常需要在此对象结构上定义新的操作。
 * （2）需要对一个对象结构中的对象进行很多不同的且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。
 * 
 * 优点
 * （1）各角色职责分离，符合单一职责原则。
 * （2）具有优秀的扩展性。
 * （3）使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化。
 * （4）灵活性。
 * 缺点
 * （1）具体元素对访问者公布细节，违反了迪米特原则。
 * （2）具体元素变更时导致修改成本大。
 * （3）违反了依赖倒置原则，为了达到“区别对待”而依赖了具体类，没有依赖抽象。
 * 
 * Android源码：
 * ButterKnife、Dagger、Retrofit
 */
class TestVisitor {
    void test() {
        //访问不同的类，用不同的处理方法
    }
}

//**********************************************************************************************************

/**
 * 中介者模式
 * 定义：中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使它们可以松散耦合。
 * 当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。
 * 场景：
 * 当对象之间的交互操作很多且每个对象的行为操作都依赖彼此时，为防止在修改一个对象的行为时，同时涉及很多其他对象的行为，可使用中介者模式。
 * 
 * 优点
 * （1）适当地使用中介者模式可以避免同事类之间的过度耦合，使得各同事类之间可以相对独立地使用。
 * （2）使用中介者模式可以将对象的行为和协作进行抽象，能够比较灵活的处理对象间的相互作用。
 * （3）使用中介者模式可以将对象间多对多的关联转变为一对多的关联，使对象间的关系易于理解和维护。
 * 缺点
 * 大多数情况下，将对象间的依赖关系封装的同事类内部就可以的，没有必要非引入中介者模式
 * 
 * Android源码：
 * Keyguard解锁屏
 */
class TestMediator {
    void test() {
        //一对多
    }
}

//**********************************************************************************************************

/**
 * 代理模式
 * 定义：为其他对象提供一种代理以控制对这个对象的访问。
 * 场景：
 * 当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，
 * 为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。
 * 
 * 优点
 * （1）对代理者与被代理者进行解耦。
 * （2）代理对象在客户端和目标对象之间起到一个中介的作用，这样可以起到对目标对象的保护。
 * 缺点
 * 基本没有缺点，真要说缺点就是设计模式的通病：对类的增加。
 * 
 * Android源码：
 * ActivityManagerProxy代理类
 */
class TestProxy {
    void test() {
        //代理律师代理诉讼
    }
}

//**********************************************************************************************************

/**
 * 组合模式
 * 定义：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。
 * 场景：
 * （1）表示对象的部分-整体层次结构时。
 * （2）从一个整体中能够独立出部分模块或功能的场景。
 * 
 * 优点
 * （1）组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，他让高层模块忽略了层次的差异，方便对整个层次结构进行控制。
 * （2）简化了高层模块的代码。
 * （3）在组合模式中增加新的枝干构件和叶子构件都很方便，无须对现有类库进行修改，符合“开闭原则”。
 * （4）对树形结构的控制变得简单。
 * 缺点
 * 组合模式不容易限制组合中的构件。因为大多数情况下，它们都来自于相同的抽象层，此时，必须进行类型检查来实现，这个实现过程较为复杂。
 * 
 * Android源码：
 * View和ViewGroup的嵌套组合
 */
class TestComposite {
    void test() {
        //对象和对象的组合接口一致
    }
}

//**********************************************************************************************************

/**
 * 适配器模式
 * 定义：适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配无法在一起工作的两个类可以在一起工作。
 * 场景：
 * （1）系统需要使用现有的类，但此类的接口不符合系统的需要，即接口不兼容。
 * （2）想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。
 * （3）需要一个统一的输出接口，而输入端的类型不可预知。
 * 
 * 优点
 * （1）更好的复用性：系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。
 * （2）更好的扩展性：在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。
 * 缺点
 * 过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，
 * 一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。
 * 
 * Android源码：
 * ListView的Adapter
 */
class TestAdapter {
    void test() {
        //接口对接，通过adapter
    }
}

//**********************************************************************************************************

/**
 * 装饰模式
 * 定义：动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。
 * 场景：
 * （1）需要透明且动态地扩展类的功能时。且在不影响其他对象的情况下。
 * （2）当不能采用继承对系统进行扩展时可以使用装饰模式。比如final类。
 * 
 * 优点
 * （1）对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。
 * （2）可以通过一种动态的方式在运行时选择不同的具体装饰类，从而实现不同的行为。
 * （3）可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。
 * （4）具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。
 * 缺点
 * （1）使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，
 * 大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。
 * （2）对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。
 * 
 * Android源码：
 * Context
 */
class TestDecorator {
    void test() {
        //装饰者类帮助装饰对象
    }
}

//**********************************************************************************************************

/**
 * 享元模式
 * 定义：采用一个共享来避免大量拥有相同内容对象的开销。使用享元模式可有效支持大量的细粒度对象。
 * 场景：
 * （1）系统中存在大量的相似对象。
 * （2）细粒度的对象都具备较接近的外部状态，而且内部状态与环境不关，也就是说对象没有特定身份。
 * （3）需要缓冲池的场景。
 * 
 * 优点
 * （1）大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能。
 * （2）使用享元模式，可以让享元对象可以在不同的环境中被共享。
 * 缺点
 * （1）使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。
 * （2）享元模式将需、享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。
 * 
 * Android源码：
 * Message.obtain();
 */
class TestFlyweight {
    void test() {
        //对象缓存起来不要频繁新建销毁
    }
}

//**********************************************************************************************************

/**
 * 外观模式
 * 定义：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易于使用。
 * 场景：
 * （1）为复杂子系统提供一个简单接口，对外隐藏子系统的具体实现、隔离变化。
 * （2）当你需要构建一个层次结构的子系统时，使用外观模式定义子系统中每层的入口点。
 * 如果子系统之间是相互依赖的，你可以让它们仅通过外观接口进行通信，从而简化了它们之间的依赖关系。
 * 
 * 优点
 * （1）对客户程序隐藏子系统的细节，因而减少了客户对于子系统的耦合，能够拥抱变化。
 * （2）外观类对子系统的接口封装，使得系统更易于使用。
 * 缺点
 * （1）外观类接口膨胀。由于子系统的接口都有外观类统一对外暴露，使得外观类的API接口较多，在一定程度上增加了用户使用成本。
 * （2）外观类没有遵循开闭原则，当业务出现变更时，可能需要直接修改外观类。
 * 
 * Android源码：
 * Context
 */
class TestFacade {
    void test() {
        //用一个类统一对外接口
    }
}

//**********************************************************************************************************

/**
 * 桥接模式
 * 定义：将抽象部分与现实部分分离，使它们都可以独立地进行变化。
 * 场景：
 * （1）如果一个系统需要在构建的抽象化角色和具体角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系。
 * （2）对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，也可以考虑使用桥接模式。
 * （3）一个类存在两个独立变化的维度，且这两个维度都需要扩展。
 * 
 * 优点
 * （1）分离抽象与现实、灵活的扩展以及对客户来说透明的实现。
 * （2）桥接模式可以取代多层继承，大大减少了子类的个数。
 * 缺点
 * 不容易设计，对开发者来说要有一定的经验要求。理解很容易，设计却不容易。
 * 
 * Android源码：
 * Window与WindowManager
 */
class TestBridge {
    void test() {
        //大杯小杯、加糖不加糖 咖啡
    }
}